@using WarHub.ArmouryModel.Source
@using WarHub.ArmouryModel
@using WarHub.ArmouryModel.EditorServices


@if (Editor is { State: { Roster: { } Roster, Catalogues: { } Catalogues } })
{
    @* TODO this render fires every time an add count gets modified
        fine for testing for now, but might expensive with bigger gamesystems *@
    <TitlePart>Add Units</TitlePart>

    <FluentTreeView>
        @foreach (var addOption in RosterAddItems.Values)
        {
            var EntryLink = addOption.EntryLink;
            if (EntryLink.Id is null)
            {
                continue;
            }
            <FluentTreeItem Expanded="true">
                <div style="display: flex; gap: 1em;">
                    <FluentNumberField TValue="int" @bind-Value="RosterAddItems[EntryLink.Id].Count" Min="0" Size="2" />
                    <span>@EntryLink.Name</span>
                    <CostDisplay Values="EntryLink.Costs" />
                </div>
            </FluentTreeItem>
        }
    </FluentTreeView>
    <FluentButton Appearance="Appearance.Accent" @onclick="()=> AddSelected()">Add</FluentButton>
    <FluentButton Appearance="Appearance.Accent" @onclick="()=> CloseMenu()">Cancel</FluentButton>
}

@code {

    [CascadingParameter, EditorRequired]
    public RosterEditor? Editor { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<IRosterOperation[]> OnAddDone { get; set; }

    private readonly Dictionary<string, AddSelection> RosterAddItems = new Dictionary<string, AddSelection>();

    protected class AddSelection
    {
        public IContainerEntrySymbol EntryLink { get; set; }

        // TODO with symbols, this val should become redundant since we can grab teh containing category/primary category
        // it might be obe now and I just don't know it ...
        public ICatalogueSymbol Catalogue { get; set; }
        public string ForceId { get; }

        public int Count;
        public AddSelection(IContainerEntrySymbol node, IForceSymbol force, ICatalogueSymbol cat)
        {
            EntryLink = node;
            Catalogue = cat;
            ForceId = force.Id is not null ? force.Id : "";
            Count = 0;
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (!(Editor is { State: { Roster: { } Roster, Catalogues: { } Catalogues } }))
            return;

        foreach (var force in Editor.State.Compilation.GlobalNamespace.Rosters[0].Forces)
        {
            // TODO WIP for symbols, blocked by not getting Cost values
            var catalogues = Editor.State.Compilation.GlobalNamespace.Catalogues.Where(x => !x.IsGamesystem);
            @* // TODO this might be better as OnParametersSet call *@
            // Get each catalogue, get all entries in catalogues, set counts for all entries to 0
            foreach (var catalogue in catalogues)
            {
                if (catalogue != null)
                {
                    foreach (var entry in catalogue.RootContainerEntries)
                    {
                        if (entry.Id == null) // make the IDE happy
                            continue;
                        RosterAddItems[entry.Id] = new AddSelection(entry, force, catalogue);
                    }
                }
            }
        }
    }

    Task AddSelected()
    {
        if (Editor?.State is not { Roster: { } rosterState })
        {
            return Task.CompletedTask;
        }

        foreach (string key in RosterAddItems.Keys)
        {
            if (RosterAddItems[key].Count < 1)
                continue;

            // TODO determine if other arrays need traversal besides SSE
            // Get the Selection this entrylink points to, then add it to the Roster
            for (int i = 0; i < RosterAddItems[key].Count; i++)
            {
                if (Editor?.State is { Roster: { } roster } state)
                {
                    Editor?.ApplyOperation(RosterOperations.AddRootEntryFromSymbol(RosterAddItems[key].EntryLink,
                    RosterAddItems[key].ForceId));
                }
            }
        }

        return OnAddDone.InvokeAsync();
    }

    Task CloseMenu()
    {
        return OnAddDone.InvokeAsync(null);
    }
}

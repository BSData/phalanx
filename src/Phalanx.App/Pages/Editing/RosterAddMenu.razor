@using WarHub.ArmouryModel.EditorServices
@using WarHub.ArmouryModel.Source
@using WarHub.ArmouryModel.Concrete;

@if (Editor is { State: { Roster: { } Roster, Catalogues: { } Catalogues } })
{
    <TitlePart>Add Units</TitlePart>
    @* TODO add a toggle button here for a Cat view (current) or a flat abc view of all entries*@

    @* TODO - this is probably unnecessary with better cat management *@
    AddEntries = new Dictionary<string, EntryLinkNode>();

    <FluentTreeView>
        @* TODO this iteration scheme is probably incomplete *@
        @foreach (var force in Roster.Forces)
        {
            @* // TODO need to get the entrylinks and entries, filter, and add those instead
                // of copies of the current roster selections *@

            var catalogues = Editor.State.Compilation.GlobalNamespace.Catalogues.Where(x => !x.IsGamesystem);

            foreach(var catalogue in catalogues)
            {
                if(catalogue != null)
                {
                    @* Console.WriteLine("Getting catalogue via symbol! " + catalogue.Name); *@
                    @* foreach(var entry in catalogue.RootResourceEntries) *@

                    foreach(var entry in catalogue.SharedSelectionEntryContainers)
                    {
                        Console.WriteLine("Entry: " +entry.Name);
                        
                        if (!AddCounts.ContainsKey(entry.Id))
                        {
                            AddCounts[entry.Id] = 0;
                        }

                        @* AddEntries[entry.Id] = entry;
                        AddCats[entry.Id] = catalogue;

                        <FluentTreeItem Expanded="true">
                            <input style="width:70px" type="number" @bind="AddCounts[item.Id]"/>

                            <span>@item.Name</span>

                            <CostDisplay Values="item.Costs" />
                        </FluentTreeItem> *@
                        
                    }
                }
            }
            var catalog = Catalogues.FirstOrDefault(x => x.Id == force.CatalogueId);

            if (catalog != null)
            {
                @* TODO this iteration scheme is probably incomplete *@
                foreach (var entryLink in catalog.EntryLinks)
                {
                    if (entryLink.Id == null) // make the IDE happy
                        break;

                    if (!AddCounts.ContainsKey(entryLink.Id))
                    {
                        AddCounts[entryLink.Id] = 0;
                    }

                    AddEntries[entryLink.Id] = entryLink;
                    AddCats[entryLink.Id] = catalog;

                    <FluentTreeItem Expanded="true">
                        <FluentNumberField TValue="int" @bind-Value="AddCounts[entryLink.Id]" Min="0" Size="2" /> 
                        <span>@entryLink.Name</span>
                        <CostDisplay Values="entryLink.Costs" />
                    </FluentTreeItem>
                }
            }
        }
    </FluentTreeView>
    <FluentButton Appearance="Appearance.Accent" @onclick="()=> AddSelected()">Add</FluentButton>
    <FluentButton Appearance="Appearance.Accent" @onclick="()=> CloseMenu()">Cancel</FluentButton>
}

@code {

    [CascadingParameter, EditorRequired]
    public RosterEditor? Editor { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<IRosterOperation[]> OnAddDone { get; set; }


    private Dictionary<string, int> AddCounts = new Dictionary<string, int>();

    @* TODO this parallel dict is probably, like, the worst thing ever. *@
    private Dictionary<string, EntryLinkNode> AddEntries = new Dictionary<string, EntryLinkNode>();
    @* TODO, either there's a nice way to make anonymous types for dicts, or byte the bullet and just make a class for Name,
        Count+cat at this point *@
    private Dictionary<string, CatalogueNode> AddCats = new Dictionary<string, CatalogueNode>();

    Task AddSelected()
    {
        if (Editor?.State is not { Roster: { } rosterState })
        {
            return Task.CompletedTask;
        }

        var operations = new List<IRosterOperation>();

        foreach (string key in AddCounts.Keys)
        {
            if (AddCounts[key] < 1)
                continue;

            // TODO this is gross; it would be good to have a EntryLink.GetTarget() call
            // though, this mess of iterations could also be optimized....
            // TODO - can entrylinks point to things besides selections? If not, kill this comment ;)
            // TODO determine if other arrays need traversal besides SSE
            // Get the Selection this entrylink points to, then add it to the Roster
            var theFind = AddCats[key].SharedSelectionEntries.Where(s => s.Id == AddEntries[key].TargetId).FirstOrDefault();

            if (theFind != null)
            {
                for (int i = 0; i < AddCounts[key]; i++)
                {
                    // TODO hardcoded Force[0]
                    if (Editor?.State is { Roster: { } roster } state){
                        Editor?.ApplyOperation(RosterOperations.AddSelectionFromLink(theFind, AddEntries[key], roster.Forces[0]));
                    }
                }
            }
        }
        return OnAddDone.InvokeAsync();
    }

    Task CloseMenu()
    {
        return OnAddDone.InvokeAsync(null);
    }
}

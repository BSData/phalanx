@page "/print"
@using Phalanx.App.Pages.Printing
@using SampleDataset
@using WarHub.ArmouryModel.EditorServices.Formatting
@using WarHub.ArmouryModel.Source
@using WarHub.ArmouryModel.Workspaces.BattleScribe

@inject Printing.RosterFormatsProvider formatter


<div style="display: grid; grid-auto-rows: max-content; gap: 20px">
    <h1>Format roster</h1>
    <label>Select roster file</label>
    <InputFile OnChange="LoadRosterFile" accept=".ros, .rosz" />

    <p>
        <strong>
            Loaded:
            @if (RosterNode is null)
            {
                <span>none</span>
            }
            else
            {
                <span>@RosterNode.Name</span>
            }
        </strong>
    </p>

    <fast-card style="padding: 20px; display: grid; grid-auto-rows: max-content; gap: 20px">
        <label style="display: flex; flex-direction: column; align-items: flex-start;">
            Select formatter
            <fast-select current-value="@SelectedFormatIndex" @onchange="OnFormatIndexSelected"
                disabled="@isCustomFormat">
                @foreach (var (format, index) in formatter.Formats.Select((x, i) => (x, i)))
                {
                    <fast-option value="@index">@format.Name</fast-option>
                }
            </fast-select>
        </label>
        <fast-checkbox current-value="@isCustomFormat" @onchange="e => isCustomFormat = !isCustomFormat">
            Custom format
        </fast-checkbox>
        @if (selectedFormat is not null)
        {
            <RosterFormatEditor @bind-Format=selectedFormat Readonly="!isCustomFormat"></RosterFormatEditor>
        }
    </fast-card>

    <fast-card style="padding: 20px; display: grid; grid-auto-rows: max-content; gap: 20px">
        <h3>Formatted output:</h3>
        @if (selectedFormat is not null && RosterNode is not null)
        {
            var formattedOutput = RosterFormatter.Format(RosterNode, selectedFormat);
            @if (selectedFormat?.OutputFormat == OutputFormat.Html)
            {
                <fast-card style="padding: 20px;">
                    @((MarkupString) formattedOutput)
                </fast-card>
            }
            else
            {
                <fast-text-area value="@formattedOutput" readonly resize="vertical">
                </fast-text-area>
            }
        }
    </fast-card>
</div>

@code {
    private RosterNode? RosterNode;
    private RosterFormat? selectedFormat;
    private bool isCustomFormat;
    private string? selectedFormatIndex;
    private string? SelectedFormatIndex
    {
        get => selectedFormatIndex;
        set
        {
            selectedFormatIndex = value;
            selectedFormat = int.TryParse(value, out var i)
            ? formatter.Formats.ElementAtOrDefault(i)
            : null;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        selectedFormat = formatter.Formats.FirstOrDefault();
        var rosterFile = SampleDataResources.CreateXmlWorkspace().DocumentsByKind[XmlDocumentKind.Roster][0];
        RosterNode = (RosterNode?)(await rosterFile.GetRootAsync());
    }

    void OnFormatIndexSelected(ChangeEventArgs e)
    {
        SelectedFormatIndex = e.Value?.ToString();
    }

    async Task LoadRosterFile(InputFileChangeEventArgs eventArgs)
    {
        // 10MB
        const long maxSize = 10 << 10 << 10;
        using var stream = eventArgs.File.OpenReadStream(maxAllowedSize: maxSize);
        // it's bad but WHAM doesn't support async reading currently :(
        // TODO fix when wham gains async support, consider migrating?
        using var memStream = new MemoryStream();
        await stream.CopyToAsync(memStream);
        memStream.Position = 0;
        RosterNode = (RosterNode)await memStream.LoadSourceAuto(eventArgs.File.Name).GetDataOrThrowAsync<RosterNode>();
    }
}

@using Microsoft.Extensions.Options
@using WarHub.ArmouryModel.DataProviders
@using WarHub.ArmouryModel.Workspaces.BattleScribe;
@using Phalanx.App.Pages.Management

@inject GalleryHttpClient client
@inject GalleryBrowserState state

@if (CatpkgGallery is { InfoCache: { } galleryInfo })
{
    <h2>System:</h2>
    <FluentSelect TValue=string Value="_selectedRepoName" ValueChanged="(x => SelectCatpkg(x))">
        @foreach (var repo in _repositories)
        {
            <FluentOption Value="repo.Name">@repo.Name</FluentOption>
        }
    </FluentSelect>

    <div>
    <FluentCard class="p-2">
        <FluentSearch Placeholder="Search Packages" class="w-100 mt-2 mb-3"/>
        <br />
        <FluentCheckbox>Show Pulled Packages</FluentCheckbox>
        <FluentCheckbox @bind-Value="ShowArchived">Show Archived Packages</FluentCheckbox>
    </FluentCard>
    <hr/>
    <div class="data-gallery">
        @foreach (var repo in _repositories)
        {
            <GalleryItem/>
        }
    </div>
</div>
}
else
{
    <FluentProgressRing />
    <p>Loading catpkg gallery...</p>
}

@code {
    [Parameter]
    public CatpkgGalleryCache? CatpkgGallery { get; set; }

    [Parameter]
    public EventCallback<CatpkgGalleryCache> CatpkgGalleryChanged { get; set; }

    XmlWorkspace? workspace;

    string _selectedRepoName = "";

    bool _showArchived;

    bool ShowArchived
    {
        get => _showArchived;
        set
        {
            _showArchived = value;
            UpdateRepositories();
        }
    }

    readonly List<CatpkgRepositoryInfo> _repositories = new();

    List<ColumnDefinition<CatpkgRepositoryInfo>> ColumnDefinitions { get; } = new()
    {
#nullable disable
        new("Name", x => x.Description),
        new("Latest Release", x => x.Version),
#nullable restore
    };

    void UpdateRepositories()
    {
        _repositories.Clear();
        if (CatpkgGallery?.InfoCache?.Repositories is { } repos)
        {
            _repositories.AddRange(repos.Where(x => x.Archived != true || ShowArchived).OrderBy(x => x.Description));
            // Clear value if we switch away from archived
            if (!ShowArchived && (repos.Where(x => x.Description == _selectedRepoName).FirstOrDefault()?.Archived ?? false))
            {
                _selectedRepoName = "";
            }
        }
    }

    CatpkgRepositoryInfo? repositoryInfo;

    async Task SelectCatpkg(string catName)
    {
        if (CatpkgGallery is null)
            return;
        _selectedRepoName = catName;
        repositoryInfo = CatpkgGallery.InfoCache?.Repositories.Find(x => x.Name == catName);
        var repoRef = new RepositoryReference(_selectedRepoName, CatpkgGallery.Reference);
        repositoryInfo = await state.Cache.GetHydratedCatpkgAsync(client, repoRef);
        workspace = await state.Cache.GetXMLWorkspaceAsync(client, repoRef);
        Console.WriteLine(workspace);
    }

    protected async override Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        if (CatpkgGallery is { Reference: { } galleryRef, InfoCache: null })
        {
            var result = await state.Cache.GetHydratedCatpkgGalleryCacheAsync(client, galleryRef);
            await CatpkgGalleryChanged.InvokeAsync(result);
        }
        UpdateRepositories();
    }
}

@typeparam TItem

<FluentSelect @bind-Value=SelectedIndex @bind-Value:after=IndexChanged>
    @for (int i = 0; i < Items.Count; i++)
    {
        var index = i;
        var item = Items[i];
        <FluentOption Value="@index">
            @if (ChildContent is not null)
            {
                @ChildContent(item)
            }
            else
            {
                @item?.ToString()
            }
        </FluentOption>
    }
</FluentSelect>

@code {
    private int? SelectedIndex { get; set; }

    [Parameter, EditorRequired]
    public IReadOnlyList<TItem> Items { get; set; } = Array.Empty<TItem>();

    [Parameter]
    public TItem? Value { get; set; }

    [Parameter]
    public EventCallback<TItem> ValueChanged { get; set; }

    [Parameter]
    public RenderFragment<TItem>? ChildContent { get; set; }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        SetValue(Value);
    }

    Task IndexChanged()
    {
        return ValueChanged.InvokeAsync(SelectedIndex is { } index && index >= 0 && index < Items.Count ? Items[index] : default);
    }

    Task SetValue(TItem? value)
    {
        int? index = null;
        for (int i = 0; i < Items.Count; i++)
        {
            if (object.ReferenceEquals(Items[i], value))
            {
                index = i;
                break;
            }
        }
        if (index != SelectedIndex)
        {
            SelectedIndex = index;
            return IndexChanged();
        }
        return Task.CompletedTask;
    }
}
